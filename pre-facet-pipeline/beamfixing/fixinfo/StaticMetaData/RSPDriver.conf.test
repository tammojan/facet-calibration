#
# THIS FILE IS FIXED, DO NOT MODIFY IT.
#
# RSPDriver.conf for testing/validating a station LCU 
#
# Configuration of the RSPDriver
#

#
# If SYNC_MODE=1 then sync will be generated by a software timer (rate controlled by SYNC_INTERVAL)
# If SYNC_MODE=2 then RSPDriver will run as fast as possible (to determine maximum update rate).
# If SYNC_MODE=3 then sync will be generated by PPS API on /dev/pps0
#
RSPDriver.SYNC_MODE=3

#
# SYNC_INTERVAL is only used when SYNC_MODE=1 to set the interval
# time of the timer.
#
RSPDriver.SYNC_INTERVAL=1.0

#
# PPS_DEVICE is only used when SYNC_MODE=3 to designate the PPS device
#
RSPDriver.PPS_DEVICE=/dev/oncore.pps.0

#
# Send signal to the RSP boards to simulate the arrival of
# a SYNC pulse (which normally comes with a frequency of 1Hz).
#
RSPDriver.SOFTPPS=0

#
# Delay the driver some number of microseconds after it receives the PPS tick
# this may be needed to synchronized the driver properly to the hardware
#
RSPDriver.PPS_DELAY=1000

#
# PPS trigger is on ASSERT (1) or CLEAR (0)
#
RSPDriver.PPS_TRIGGER=1

#
# Specify the MAC addresses of the control port (MAC) of RSP boards
#
# NOTE: not used yet!
RSPDriver.MAC_ADDR_MASK=10:FA:00:00:%02x:00

# old-way of specifying the MAC addresses
#
RSPDriver.MAC_ADDR_0=10:FA:00:00:00:00
RSPDriver.MAC_ADDR_1=10:FA:00:00:01:00
RSPDriver.MAC_ADDR_2=10:FA:00:00:02:00
RSPDriver.MAC_ADDR_3=10:FA:00:00:03:00
RSPDriver.MAC_ADDR_4=10:FA:00:00:04:00
RSPDriver.MAC_ADDR_5=10:FA:00:00:05:00
RSPDriver.MAC_ADDR_6=10:FA:00:00:06:00
RSPDriver.MAC_ADDR_7=10:FA:00:00:07:00
RSPDriver.MAC_ADDR_8=10:FA:00:00:08:00
RSPDriver.MAC_ADDR_9=10:FA:00:00:09:00
RSPDriver.MAC_ADDR_10=10:FA:00:00:0A:00
RSPDriver.MAC_ADDR_11=10:FA:00:00:0B:00
RSPDriver.MAC_ADDR_12=10:FA:00:00:0C:00
RSPDriver.MAC_ADDR_13=10:FA:00:00:0D:00
RSPDriver.MAC_ADDR_14=10:FA:00:00:0E:00
RSPDriver.MAC_ADDR_15=10:FA:00:00:0F:00
RSPDriver.MAC_ADDR_16=10:FA:00:00:10:00
RSPDriver.MAC_ADDR_17=10:FA:00:00:11:00
RSPDriver.MAC_ADDR_18=10:FA:00:00:12:00
RSPDriver.MAC_ADDR_19=10:FA:00:00:13:00
RSPDriver.MAC_ADDR_20=10:FA:00:00:14:00
RSPDriver.MAC_ADDR_21=10:FA:00:00:15:00
RSPDriver.MAC_ADDR_22=10:FA:00:00:16:00
RSPDriver.MAC_ADDR_23=10:FA:00:00:17:00

#
# CEP Output settings (CDO) for the four lanes
#
# Each station has up to four output lanes, corresponding
# to the four (logical) SERDES lanes that connect all the
# RSP boards in a station in a ring.
#
# LANE_x_BLET_OUT, LANE_x_XLET_OUT
# --------------------------------
# These settings determine which RSP board outputs beamlets (BLET)
# and crosslets (XLET) of lane x on the CEP output port. Currently
# (and this probably won't be changed) the BLET and XLET setting must
# be identical per lane, e.g. if LANE_0_BLET_OUT is X, then
# LANE_0_XLET_OUT must also be X. This setting controls the setting
# of the RAD register. The RSP board immediately following
# the output board will ignore input data thus creating a route from
# first to last board the latter being the output board.
#
# Complete beamforming and cross-correlation data and statistics
# will be available only on the last RSP board in a ring (the output board).
# All other boards in the ring will produce partial data and statistics.
#
# Note: the specified RSP board index will be taken
# modulo N_RSPBOARDS to prevent out of range indices.
#
# LANE_x_SRCMAC, LANE_x_SRCIP, LANE_x_DSTMAC, LANE_x_DSTIP
# --------------------------------------------------------
# Output of RSP boards is packaged in UDP/IP packets. These
# packets need a source MAC- and IP-address and a destination
# MAC- and IP-address.
#
# The RSP board that outputs lane x will use the MAC- and IP-
# addresses specified here. Note that changing the output
# lane of beamlet LANE_x_BLET_OUT to a different
# RSP board will move these addresses to the new RSP board.
# Only RSP boards that are assigned output of one of the four
# lanes will produce ethernet packets and use these MAC- and
# IP-addresses.
#
#
# The MAC and IP numbers are FAKE numbers! This is for test and 
# validation only!
#
RSPDriver.LANE_00_BLET_OUT= 0
RSPDriver.LANE_00_XLET_OUT= 0
RSPDriver.LANE_00_SRCMAC  = 00:22:86:00:00:00
RSPDriver.LANE_00_SRCIP   = 10.144.255.1
RSPDriver.LANE_00_DSTMAC  = 00:14:5E:7D:95:60
RSPDriver.LANE_00_DSTIP   = 10.170.0.251

RSPDriver.LANE_01_BLET_OUT=1
RSPDriver.LANE_01_XLET_OUT=0
RSPDriver.LANE_01_SRCMAC  = 00:22:86:00:01:00
RSPDriver.LANE_01_SRCIP   = 10.144.255.2
RSPDriver.LANE_01_DSTMAC  = 00:14:5E:7D:95:61
RSPDriver.LANE_01_DSTIP   = 10.170.0.252

RSPDriver.LANE_02_BLET_OUT=2
RSPDriver.LANE_02_XLET_OUT=0
RSPDriver.LANE_02_SRCMAC  = 00:22:86:00:02:00
RSPDriver.LANE_02_SRCIP   = 10.144.255.3
RSPDriver.LANE_02_DSTMAC  = 00:14:5E:7D:95:62
RSPDriver.LANE_02_DSTIP   = 10.170.0.253


RSPDriver.LANE_03_BLET_OUT=3
RSPDriver.LANE_03_XLET_OUT=0
RSPDriver.LANE_03_SRCMAC  = 00:22:86:00:03:00
RSPDriver.LANE_03_SRCIP   = 10.144.255.4
RSPDriver.LANE_03_DSTMAC  = 00:14:5E:7D:95:63
RSPDriver.LANE_03_DSTIP   = 10.170.0.254

#
# IGNORE_REMOTE_DATA
# ------------------
# Setting IGNORE_REMOTE_DATA to 1 will force all boards
# to ignore remote data. This can be used to check
# for difference between operation with data from SERDES
# ring and without.
#
RSPDriver.IGNORE_REMOTE_DATA=0

#
# CDO Control
# This controls the format of CEP output data from the serdes lane specified in
# the previous section.
#
# CDO_ENABLE=(0|1)   : when 0 disable output on all RSP boards
# CDO_N_BLOCKS=(N)   : Set number of blocks of N_BEAMLETS beamlets per output Ethernet frame
# CDO_N_BEAMLETS=(N) : Set number of beamlets to output in each block
#
RSPDriver.CDO_ENABLE=1
RSPDriver.CDO_N_BLOCKS=16
RSPDriver.CDO_N_BEAMLETS=1
RSPDriver.FB_ENABLE=1

#
# Specify the absolute backplane index of the first
# RSP board in hexadecimal
#
# MAC address is equal to : 10:FA:00:00:XX:00
#
RSPDriver.XST_FIRST_RSP_BOARD=0x00

#
# Ethernet interface on which to contact the RSP boards.
# This interface would normally be connected to the switch.
#
RSPDriver.IF_NAME=eth1

#
# Make sure that initially the
# beamlet statistics match the subband statistics
#
RSPDriver.IDENTITY_WEIGHTS=1
RSPDriver.FIRST_SUBBAND=0

#
# Select LOOPBACK_MODE mode
#
# If LOOPBACK_MODE == 0, the WRITE is done first.
# In this mode the RSPDriver checks that what was
# written is correctly read back from the board. This can
# be used to check that the RSP board or the EPAStub
# functions correctly. Read results are not stored in
# the RSPDriver cache.
#
# If LOOPBACK_MODE == 1, the READ is done first.
# In this mode you can check with Ethereal that what was
# read from the RSP board or EPAStub is written back in
# the same way. This is used to check whether the RSPDriver
# stores the information at the correct location in its cache.
# Of course in this mode reads results are stored in the
# RSPDriver cache.
#
RSPDriver.LOOPBACK_MODE=0

#
# Enable/disable certain parts of the update cycle.
# The order of these config variables does not
# alter the order the update actions are performed.
#
RSPDriver.WRITE_RSU=1
RSPDriver.WRITE_BS=1
RSPDriver.WRITE_CDO=1
# READ_CDO, if set to 1 reads back contents of pid=CDO, regid=0x01
# This can be used to verify that the UDP/IP header is correctly
# written to the register.
RSPDriver.READ_CDO=0
RSPDriver.WRITE_RAD=1
RSPDriver.READ_STATUS=1
RSPDriver.WRITE_XBF=1
RSPDriver.WRITE_BF=1
RSPDriver.WRITE_SS=1
RSPDriver.WRITE_RCU=1
RSPDriver.WRITE_RCU_PROTOCOL=1
RSPDriver.WRITE_HBA_PROTOCOL=1
RSPDriver.READWRITE_TDS_PROTOCOL=1
RSPDriver.READ_SST=1
RSPDriver.READ_BST=1
RSPDriver.WRITE_WG=1
RSPDriver.WRITE_WG_WAVE=0
RSPDriver.READ_RCU_RESULT=1
RSPDriver.READ_HBA_RESULT=1
RSPDriver.READ_VERSION=1
RSPDriver.READ_XST=1
RSPDriver.WRITE_TIMESTAMP=1
RSPDriver.READWRITE_TDSSTATUS=1
RSPDriver.WRITE_TBB=1
RSPDriver.WRITE_SI=1
RSPDriver.READ_SI=1
RSPDriver.SPLITTER=1

#
# TDS_CONTROL
#
# 0x00111111 : Only first RSP board in each rack of the six racks
#              controls the TD-oard
#
RSPDriver.TDS_CONTROL=0x00111111

#
# Optionally read RW-registers.
#
RSPDriver.READ_BF=0
RSPDriver.READ_SS=0
RSPDriver.READ_RCU=0
RSPDriver.READ_WG=0

#
# Specify the default sampling frequency that should be programmed
# into the hardware when the driver starts.
# Currently allowed values are: 0 (off), 160 (MHz) and 200 (MHz)
#
RSPDriver.DEFAULT_SAMPLING_FREQUENCY=200

#
# Specify how the rspdriver should operate:
# 0: one RSP driver active --> control all boards
# 1: many RSP drivers active --> control boards -I<n> only
#
RSPDriver.OPERATION_MODE=0

#
# Set initial gain for beamforming and cross-correlation
#
RSPDriver.BF_GAIN=8000
RSPDriver.XC_GAIN=8000

#
# If set to 1 (true), then the cross-correlation array will
# be filled completely by copying the conjugate of a cross-correlation
# across the diagonal if a value equals zero.
#
RSPDriver.XC_FILL=1

#
# Disable initialization to enable testing on a system without hardware
#
RSPDriver.DISABLE_INIT=0

#
# Ignore result of HBA i2c sequence
#
RSPDriver.HBA_RESULT_IGNORE=0

#
# The 'server address' is the address of the i2c server in the HBA tile.
# By default a tile should have addresses 1-16 for the 16 delays.
# The current HBA tile (connected to FTS-2 setup) has range 3-18
# The HBA_SERVER_ADDRESS_OFFSET controls the start of the range.
#
# Note: Addresses 0 indicates broadcast so a valid offset will be greater than 0.
#
RSPDriver.HBA_SERVER_ADDRESS_OFFSET=1

#
# Allow/deny writing raw datablocks. This is only needed for testing!
RSPDriver.READ_RAW_DATA  = 1
RSPDriver.WRITE_RAW_DATA = 1

